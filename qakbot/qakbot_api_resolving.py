import argparse
from malduck import crc32
from icecream import ic
import struct
import os
import pefile


def unhex(hex_string):
    import binascii

    if type(hex_string) == str:
        return binascii.unhexlify(hex_string.encode("utf-8"))
    else:
        return binascii.unhexlify(hex_string)


def tohex(data):
    import binascii

    if type(data) == str:
        return binascii.hexlify(data.encode("utf-8"))


def string_lookup(strings_key, strings_data, offset):
    strings_out = []
    for i in range(len(strings_data)):
        strings_out.append(strings_key[i % len(strings_key)] ^ strings_data[i])
    strings_table = bytes(strings_out)[offset:].decode("latin1")
    return strings_table.split("\x00")[0]


def unsigned_to_signed(unsigned):
    """Because for whatever reason I couldn't get the bytestring directly"""
    signed = []
    for elem in unsigned:
        signed.append(elem + (2 ** 32) & 0xFF)
    return bytes(bytearray(signed))


def extract_list_hashes(xorValue, hashListAddress, hashListSize):
    """Extracts the list of hashes from the memory address"""
    hashes_list = []
    retrievedDwordList = getBytes(toAddr(hashListAddress), hashListSize)
    retrievedDwordList = unsigned_to_signed(retrievedDwordList)
    for i in range(0, hashListSize, 4):
        hashes_list.append(
            (
                (struct.unpack("I", retrievedDwordList[i : i + 4])[0] ^ xorValue)
                & 0xFFFFFFFF
            )
        )
    return hashes_list


def retrieve_func_args(xref):
    """Retrieves the memory address where the list of hashes is located"""
    xor_decode = toAddr(0x1000E365)
    callee = xref.getFromAddress()
    inst = getInstructionBefore(getInstructionAt(callee))
    go_on = True
    dll_offset = 0
    array_size = 0
    ptr_array = 0
    while go_on:
        mnemonic = inst.getMnemonicString()
        if (mnemonic == "PUSH") and (inst.getOperandType(0) == 16384):
            if array_size == 0:
                array_size = inst.getOpObjects(0)[0].getValue()
            else:
                dll_offset = inst.getOpObjects(0)[0].getValue()

        elif mnemonic == "MOV":
            str_inst = inst.toString()
            if "ECX" in str_inst:
                ptr_array = inst.getOpObjects(1)[0].toString()
            elif ("EDX" in str_inst) and (inst.getOperandType(1) == 16384):
                array_size = inst.getOpObjects(1)[0].getValue()
            elif ("ESP" in str_inst) and (inst.getOperandType(1) == 16384):
                dll_offset = inst.getOpObjects(1)[0].getValue()

        if array_size != 0 and ptr_array != 0 and dll_offset != 0:
            go_on = False
        inst = inst.getPrevious()
    return ptr_array, array_size, dll_offset


def create_ghidra_struct(dll_name, api_list):
    """Create a Ghidra struct for the dll_name containing the api_list"""
    start()  # Needed, see https://github.com/justfoxing/ghidra_bridge/issues/
    data_type_manager = currentProgram.getDataTypeManager()
    ptn = (
        ghidra.program.model.data.PointerDataType()
    )  # Couldn't create for example 'VirtualAlloc *' datatype, open for idea if you have one
    struct = ghidra.program.model.data.StructureDataType(None, dll_name + "_arr", 0)
    for api in api_list:
        struct.add(ptn, 4, api, "")
    data_type_manager.addDataType(struct, None)
    end(True)


def parse_dll_exports(dll_name):
    """Extracts all of the exported functions from the dll"""
    # https://github.com/phracker/HopperScripts/blob/master/list-pe-exports.py
    dllFileName = os.path.join("PATH_TO_DLL_FOLDER", dll_name.strip("\x00"))
    if not os.path.exists(dllFileName):
        print("Failed to locate DLL %s." % dllFileName)
        return False
    pe = pefile.PE(dllFileName, fast_load=True)
    pe.parse_data_directories(
        directories=[pefile.DIRECTORY_ENTRY["IMAGE_DIRECTORY_ENTRY_EXPORT"]]
    )
    return [dllExport.name for dllExport in pe.DIRECTORY_ENTRY_EXPORT.symbols]


def brute_force_crc32_hash(dll_name, located_api_hash):
    """Brute force for the matching crc32 hash"""
    resolvedAPI = None
    listOfExports = parse_dll_exports(dll_name)
    listOfExports = filter(None, listOfExports)
    for dllExport in listOfExports:
        if crc32(dllExport) & 0xFFFFFFFF == located_api_hash:
            resolvedAPI = dllExport
            break
    if resolvedAPI == None:
        resolvedAPI = "ErrorLoadingCorrectAPI::%X" % (located_api_hash)
    return resolvedAPI


def get_decode_strings_params(functionCrossReference):
    """Get the data memory address and the key memory address as well the data size, used for deobfuscation"""
    str_offset = 0
    data_size = 0
    key_addr = 0
    str_addr = 0
    xrefs = getReferencesTo(functionCrossReference)
    callee = xrefs[0].getFromAddress()
    inst = getInstructionBefore(getInstructionAt(callee))
    go_on = True
    while go_on:
        mnemonic = inst.getMnemonicString()
        if mnemonic == "PUSH":
            key_addr = inst.getOpObjects(0)[0].toString()
        elif mnemonic == "MOV":
            str_inst = inst.toString()
            if "ECX" in str_inst:
                str_offset = inst.getOpObjects(1)[0].toString()
            elif ("EDX" in str_inst) and (inst.getOperandType(1) == 16384):
                data_size = inst.getOpObjects(1)[0].getValue()
        if str_offset != 0 and data_size != 0 and key_addr != 0:
            go_on = False
        inst = inst.getPrevious()
    return str_offset, data_size, key_addr


if __name__ == "__main__":
    """Ghidra bridge related"""
    in_ghidra = False
    try:
        import ghidra

        # we're in ghidra!
        in_ghidra = True
    except ModuleNotFoundError:
        # not ghidra
        pass

    if in_ghidra:
        import ghidra_bridge_server

        script_file = getSourceFile().getAbsolutePath()
        # spin up a ghidra_bridge_server and spawn the script in external python to connect back to it
        ghidra_bridge_server.GhidraBridgeServer.run_script_across_ghidra_bridge(
            script_file
        )
    else:
        # we're being run outside ghidra! (almost certainly from spawned by run_script_across_ghidra_bridge())
        parser = argparse.ArgumentParser(
            description="Qakbot script that deobfuscate and create structures for WINAPI calls"
        )
        # the script needs to handle these command-line arguments and use them to connect back to the ghidra server that spawned it
        parser.add_argument(
            "--connect_to_host",
            type=str,
            required=False,
            default="127.0.0.1",
            help="IP to connect to the ghidra_bridge server",
        )
        parser.add_argument(
            "--connect_to_port",
            type=int,
            required=False,
            help="Port to connect to the ghidra_bridge server",
            default="13337",
        )
        args = parser.parse_args()
        import ghidra_bridge
        import binascii

        b = ghidra_bridge.GhidraBridge(namespace=globals(), response_timeout=300)
        #############################################################
        #                   NEEDED VALUES                           #
        #############################################################
        xor_value = 0x218FE95B  # value of the xor operand used for crc32 hashs
        string_func = toAddr(
            0x10008650
        )  # address of the function that deobfuscate the strings (it looks like mw_decode_data((int)&xored_data,3660,(int)&xor_key,param_1,param_1);)
        core_function = toAddr(
            0x1000E365
        )  # Address of the function that resolves api calls (it looks like wrapper_resolve_apis((short *)&DAT_1001bd38,8,188);)
        #############################################################

        xrefs = getReferencesTo(core_function)  # Get the list of all cross references
        data_addr, data_size, key_addr = get_decode_strings_params(string_func)
        key = unsigned_to_signed(getBytes(toAddr(key_addr), 90))
        data = unsigned_to_signed(getBytes(toAddr(data_addr), data_size))
        for xref in xrefs:
            ptr_array, array_size, dll_offset = retrieve_func_args(xref)
            dll_name = string_lookup(key, data, dll_offset)
            api_list = []
            hashes_list = extract_list_hashes(xor_value, ptr_array, array_size)
            for extracted_hash in hashes_list:
                api_name = brute_force_crc32_hash(dll_name, extracted_hash)
                api_list.append(api_name)
            create_ghidra_struct(dll_name, api_list)
